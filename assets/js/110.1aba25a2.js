(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{729:function(e,t,v){"use strict";v.r(t);var _=v(6),o=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"深入解析-eventloop-和浏览器渲染、帧动画、空闲回调的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#深入解析-eventloop-和浏览器渲染、帧动画、空闲回调的关系"}},[e._v("#")]),e._v(" 深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系")]),e._v(" "),v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),v("p",[e._v("关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：")]),e._v(" "),v("ol",[v("li",[e._v("每一轮 Event Loop 都会伴随着渲染吗？")]),e._v(" "),v("li",[v("code",[e._v("requestAnimationFrame")]),e._v(" 在哪个阶段执行，在渲染前还是后？在 "),v("code",[e._v("microTask")]),e._v(" 的前还是后？")]),e._v(" "),v("li",[v("code",[e._v("requestIdleCallback")]),e._v(" 在哪个阶段执行？如何去执行？在渲染前还是后？在 "),v("code",[e._v("microTask")]),e._v(" 的前还是后？")]),e._v(" "),v("li",[v("code",[e._v("resize")]),e._v("、"),v("code",[e._v("scroll")]),e._v(" 这些事件是何时去派发的。")])]),e._v(" "),v("p",[e._v("这些问题并不是刻意想刁难你，如果你不知道这些，那你可能并不能在遇到一个动画需求的时候合理的选择 "),v("code",[e._v("requestAnimationFrame")]),e._v("，你可能在做一些需求的时候想到了 "),v("code",[e._v("requestIdleCallback")]),e._v("，但是你不知道它运行的时机，只是胆战心惊的去用它，祈祷不要出线上 bug。")]),e._v(" "),v("p",[e._v("这也是本文想要从规范解读入手，深挖底层的动机之一。本文会酌情从规范中排除掉一些比较晦涩难懂，或者和主流程不太相关的概念。更详细的版本也可以直接去读这个规范，不过比较费时费力。")]),e._v(" "),v("blockquote",[v("p",[e._v("其实我看到这个地方的时候就知道这篇文章值得一读，因为它不是单纯讲进程、线程、JS事件循环（宏任务、微任务）的文章。前言中提到的问题确实不太熟悉，说不知道吧了解一点，说知道吧，也不能很明确的说出来。是时候梳理一波了。对文章作者公众号『 前端从进阶到入院』表示感谢~~")])]),e._v(" "),v("h2",{attrs:{id:"事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[e._v("#")]),e._v(" 事件循环")]),e._v(" "),v("p",[e._v("我们先依据"),v("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTML 官方规范"),v("OutboundLink")],1),e._v("从浏览器的事件循环讲起，因为剩下的 API 都在这个循环中进行，它是浏览器调度任务的基础。")]),e._v(" "),v("h3",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),v("p",[e._v("为了协调时间，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节描述的事件循环。")]),e._v(" "),v("h3",{attrs:{id:"流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[e._v("#")]),e._v(" 流程")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("从任务队列中取出一个"),v("strong",[e._v("宏任务")]),e._v("并执行；")])]),e._v(" "),v("li",[v("p",[e._v("检查微任务队列，执行并清空"),v("strong",[e._v("微任务")]),e._v("队列，如果在微任务的执行中又加入新的微任务，也会在这一步一起执行。")])]),e._v(" "),v("li",[v("p",[e._v("进入更新渲染阶段，判断是否需要渲染，这里有一个"),v("code",[e._v("rendering opportunity")]),e._v("的概念，也就是说："),v("strong",[e._v("不一定每一轮event loop都会对应一次浏览器渲染")]),e._v("，要根据其屏幕刷新率、页面性能、页面是否在后台运行来共同决定。通常来说，这个渲染间隔是固定的。（所以多个task很可能在一次渲染之间执行）")]),e._v(" "),v("ul",[v("li",[e._v("浏览器会尽可能的保持帧率稳定，例如页面性能无法维持60fps（每16.66ms渲染一次）的话，那么浏览器会选择30fps的更新速率，而不是偶尔丢帧。")]),e._v(" "),v("li",[e._v("如果浏览器上下文不可见，那么页面帧率会降低到4fps左右甚至更低。")]),e._v(" "),v("li",[e._v("如果满足以下条件，也会跳过渲染：\n"),v("ul",[v("li",[e._v("浏览器判断更新渲染不会带来视觉上的改变，且")]),e._v(" "),v("li",[v("code",[e._v("map of animation frame callback")]),e._v("为空，也就是帧动画回调为空，可以通过"),v("code",[e._v("requestAnimationFrame")]),e._v("来请求帧动画。")])])])])]),e._v(" "),v("li",[v("p",[e._v("如果上述的判断决定本轮不需要渲染，那么下面的几步（5-9）也"),v("strong",[e._v("不会")]),e._v("继续运行：")]),e._v(" "),v("blockquote",[v("p",[e._v("This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates. 有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 "),v("code",[e._v("microTask")]),e._v("的执行，而不会穿插屏幕渲染相关的流程（比如"),v("code",[e._v("requestAnimationFrame")]),e._v("，下面会写一个例子）。")])])]),e._v(" "),v("li",[v("p",[e._v("对于需要渲染的文档，如果窗口大小发生了变化，执行监听的"),v("code",[e._v("resize")]),e._v("方法。")])]),e._v(" "),v("li",[v("p",[e._v("对于需要渲染的文档，如果页面发生了滚动，执行"),v("code",[e._v("scroll")]),e._v("方法。")])]),e._v(" "),v("li",[v("p",[e._v("对于需要渲染的文档，执行帧回调动画，也就是"),v("code",[e._v("requestAnimationFrame")]),e._v("的回调。")])]),e._v(" "),v("li",[v("p",[e._v("对于需要渲染的文档，执行"),v("code",[e._v("IntersectionObserve")]),e._v("的回调。")])]),e._v(" "),v("li",[v("p",[e._v("对于需要渲染的文档，***重新渲染***绘制用户界面。")])]),e._v(" "),v("li",[v("p",[e._v("判断"),v("code",[e._v("task队列")]),e._v("和"),v("code",[e._v("microTask")]),e._v("队列是否都为空，如果是的话，则进行"),v("code",[e._v("Idle")]),e._v("空闲周期的算法，判断是否要执行"),v("code",[e._v("requestIdleCallback")]),e._v("的回调函数。")])])]),e._v(" "),v("p",[e._v("对于"),v("code",[e._v("resize")]),e._v(" 和 "),v("code",[e._v("scroll")]),e._v("来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据"),v("a",{attrs:{href:"https://drafts.csswg.org/cssom-view/#scrolling-events",target:"_blank",rel:"noopener noreferrer"}},[e._v("CSSOM 规范"),v("OutboundLink")],1),e._v("所讲，浏览器会保存一个 "),v("code",[e._v("pending scroll event targets")]),e._v("，等到事件循环中的 "),v("code",[e._v("scroll")]),e._v("这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。"),v("code",[e._v("resize")]),e._v("也是同理。")]),e._v(" "),v("p",[e._v("可以在这个流程中仔细看一下「宏任务」、「微任务」、「渲染」之间的关系。")]),e._v(" "),v("h2",{attrs:{id:"多任务队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多任务队列"}},[e._v("#")]),e._v(" 多任务队列")]),e._v(" "),v("p",[v("code",[e._v("task")]),e._v("队列并不是像我们想象的那样只有一个，根据规范里的描述：")]),e._v(" "),v("blockquote",[v("p",[e._v("An event loop has one or more task queues. A task queue is a set of tasks. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.")])]),e._v(" "),v("p",[e._v("事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：")]),e._v(" "),v("ol",[v("li",[e._v("鼠标和键盘事件")]),e._v(" "),v("li",[e._v("其他一些Task")])]),e._v(" "),v("p",[e._v("浏览器会在保持任务顺序的前提下，可能会分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他"),v("code",[e._v("Task")]),e._v("，并且保证不会『饿死』它们。")]),e._v(" "),v("p",[e._v("这个规范也导致 Vue 2.0.0-rc.7 这个版本 "),v("code",[e._v("nextTick")]),e._v(" 采用了从微任务 "),v("code",[e._v("MutationObserver")]),e._v(" 更换成宏任务 "),v("code",[e._v("postMessage")]),e._v(" 而导致了一个 "),v("a",{attrs:{href:"https://github.com/vuejs/vue/issues/3771",target:"_blank",rel:"noopener noreferrer"}},[e._v("Issue"),v("OutboundLink")],1),e._v("。")]),e._v(" "),v("hr"),e._v(" "),v("p",[e._v("非原文")]),e._v(" "),v("p",[e._v("下面为具体回答：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/yancqS/blogImage/raw/master/blogImage/20210830195538.png",alt:""}})]),e._v(" "),v("hr"),e._v(" "),v("p",[e._v("目前由于一些“未知”的原因，jsfiddle 的案例打不开了。简单描述一下就是采用了 "),v("code",[e._v("task")]),e._v(" 实现的 "),v("code",[e._v("nextTick")]),e._v("，在用户持续滚动的情况下 "),v("code",[e._v("nextTick")]),e._v(" 任务被延后了很久才去执行，导致动画跟不上滚动了。")]),e._v(" "),v("p",[e._v("迫于无奈，尤大还是改回了 "),v("code",[e._v("microTask")]),e._v(" 去实现 "),v("code",[e._v("nextTick")]),e._v("，当然目前来说 "),v("code",[e._v("promise.then")]),e._v(" 微任务已经比较稳定了，并且 Chrome 也已经实现了 "),v("code",[e._v("queueMicroTask")]),e._v(" 这个官方 API。不久的未来，我们想要调用微任务队列的话，也可以节省掉实例化 "),v("code",[e._v("Promise")]),e._v(" 在开销了。")]),e._v(" "),v("p",[e._v("从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。")]),e._v(" "),v("p",[e._v("下面的章节中咱们来详细聊聊 "),v("code",[e._v("requestIdleCallback")]),e._v(" 和 "),v("code",[e._v("requestAnimationFrame")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"requestanimationframe"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe"}},[e._v("#")]),e._v(" requestAnimationFrame")]),e._v(" "),v("blockquote",[v("p",[e._v("以下内容中"),v("code",[e._v("requestAnimationFrame")]),e._v(" 简称 "),v("code",[e._v("rAF")])])]),e._v(" "),v("p",[e._v("在解读规范的过程中，我们发现"),v("code",[e._v("requestAnimationFrame")]),e._v("的回调有两个特征：")]),e._v(" "),v("ol",[v("li",[e._v("在重新渲染前调用")]),e._v(" "),v("li",[e._v("很可能在宏任务之后不调用")])]),e._v(" "),v("blockquote",[v("p",[e._v("非原文：第二点主要是因为：不一定每一轮event loop都会对应一次浏览器渲染")])]),e._v(" "),v("p",[e._v("我们来分析一下，为什么要在重新渲染前调用？因为"),v("code",[e._v("rAF")]),e._v("是官方推荐来做一些流畅动画说应该使用的API，做动画不可避免的会去更改DOM，而如果在渲染之后再去更改DOM，那就只能在下一次渲染机会的时候才能去绘制出来，这显然是不合理的。")]),e._v(" "),v("p",[v("code",[e._v("rAF")]),e._v("在浏览器决定渲染之前给你最后一个机会去改变DOM属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个"),v("code",[e._v("setTimeoue")]),e._v("的例子来对比。")]),e._v(" "),v("h3",{attrs:{id:"闪烁动画"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闪烁动画"}},[e._v("#")]),e._v(" 闪烁动画")]),e._v(" "),v("p",[e._v("假设我们现在想要")]),e._v(" "),v("p",[v("video",{attrs:{src:"https://gitee.com/yancqS/blogImage/raw/master/blogImage/20210831005757.mp4",controls:"",width:"100%",height:"460px"}})]),e._v(" "),v("comment")],1)}),[],!1,null,null,null);t.default=o.exports}}]);